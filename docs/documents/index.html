<!DOCTYPE html>
<html lang='en-US' xml:lang='en-US' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <title>Mongoid Documentation: Documents</title>
    <link href='/stylesheets/docs.css' media='all' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <div id='docs'>
      <div id='page_menu'>
        <ul>
          <li class=''>
            <a href='/'>Home</a>
          </li>
          <li class='current_page_item'>
            <a href='/docs/installation/'>Documentation</a>
          </li>
          <li class=''>
            <a href='/links/'>Links</a>
          </li>
          <li class=''>
            <a href='/about/'>About</a>
          </li>
        </ul>
      </div>
      <div id='header'>
        <a href='/'>
          <h1 class='logo' title='[mon-goyd]'>MONGOID</h1>
        </a>
        <a class='docs_header' href='../installation/'>Documentation</a>
      </div>
      <div class='main'>
        <div class='border'>
          <div class='content_body colorize'>
            <h2>Documents</h2>
            <div class="text">&#x000A;  <p>&#x000A;    Documents are the core objects in Mongoid and any object that is to be&#x000A;    persisted to the database must include <tt>Mongoid::Document</tt>.&#x000A;    The representation of a Document in MongoDB is a BSON object&#x000A;    that is very similar to a Ruby hash or JSON object. Documents can be&#x000A;    stored in their own collections in the database, or can be embedded&#x000A;    in other Documents <i>n</i> levels deep.&#x000A;  </p>&#x000A;</div>&#x000A;<div class="title">Defining Documents in Mongoid</div>&#x000A;<div class="text">&#x000A;  <p>&#x000A;    Consider a simple class for modeling a person in an application. A person&#x000A;    may have a first name, last name, and middle initial. We can define these&#x000A;    attributes on a person by defining fields on our person object. Fields will&#x000A;    default to type <tt>String</tt> in Mongoid.&#x000A;  </p>&#x000A;  <tt>person.rb</tt>:&#x000A;  <pre><code class="language-ruby"><span class="r">class</span> <span class="cl">Person</span>&#x000A;  include <span class="co">Mongoid</span>::<span class="co">Document</span>&#x000A;  field <span class="sy">:first_name</span>&#x000A;  field <span class="sy">:middle_initial</span>&#x000A;  field <span class="sy">:last_name</span>&#x000A;<span class="r">end</span></code></pre>&#x000A;  <p>&#x000A;    Fields other than strings must define a type in order to be properly&#x000A;    typecasted when being set. Currently the valid types in Mongoid are:&#x000A;    <tt>Array</tt>, <tt>BigDecimal</tt>,&#x000A;    <tt>Boolean</tt>, <tt>Date</tt>, <tt>DateTime</tt>, <tt>Float</tt>,&#x000A;    <tt>Hash</tt>, <tt>Integer</tt>, <tt>String</tt>, <tt>Symbol</tt>,&#x000A;    <tt>Time</tt> and any object that inherits from&#x000A;    <tt>Mongoid::Document</tt>. BigDecimals will get converted to and&#x000A;    from Strings in the database.&#x000A;  </p>&#x000A;  <tt>person.rb</tt>:&#x000A;  <pre><code class="language-ruby"><span class="r">class</span> <span class="cl">Person</span>&#x000A;  include <span class="co">Mongoid</span>::<span class="co">Document</span>&#x000A;  field <span class="sy">:birthday</span>, <span class="sy">:type</span> =&gt; <span class="co">Date</span>&#x000A;<span class="r">end</span></code></pre>&#x000A;  <p>&#x000A;    Fields may also have default values, set by adding a default option&#x000A;    when defining the field. Note that default values MUST match the type&#x000A;    of the field, and can accept lambdas.&#x000A;  </p>&#x000A;  <tt>person.rb</tt>:&#x000A;  <pre><code class="language-ruby"><span class="r">class</span> <span class="cl">Person</span>&#x000A;  include <span class="co">Mongoid</span>::<span class="co">Document</span>&#x000A;  field <span class="sy">:blood_alcohol_level</span>, <span class="sy">:type</span> =&gt; <span class="co">Float</span>, <span class="sy">:default</span> =&gt; <span class="fl">0.0</span>&#x000A;<span class="r">end</span></code></pre>&#x000A;  <p>&#x000A;    You can override the type of the unique _id field on the collection with the&#x000A;    identity keyword. In the following example, the type of the _id field will&#x000A;    now be String. This is useful if you would like the _id field to be&#x000A;    something other than an ObjectId.&#x000A;  </p>&#x000A;  <tt>person.rb</tt>:&#x000A;  <pre><code class="language-ruby"><span class="r">class</span> <span class="cl">Person</span>&#x000A;  include <span class="co">Mongoid</span>::<span class="co">Document</span>&#x000A;  identity <span class="sy">:type</span> =&gt; <span class="co">String</span>&#x000A;<span class="r">end</span></code></pre>&#x000A;</div>&#x000A;<div class="title">Instantiating Documents</div>&#x000A;<div class="text">&#x000A;  <p>&#x000A;    Documents are instantiated by calling <tt>new</tt> on the document and passing&#x000A;    it a hash of attributes. You can also pass a block.&#x000A;  </p>&#x000A;  <p>&#x000A;    If you have set the <tt>allow_dynamic_fields</tt> configuration option to&#x000A;    <tt>false</tt> and an attribute exists in the hash that is not defined as a field&#x000A;    or an association then an exception will be raised.&#x000A;  </p>&#x000A;  <pre><code class="language-ruby">person = <span class="co">Person</span>.new(<span class="sy">:first_name</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Ludwig</span><span class="dl">"</span></span>, <span class="sy">:last_name</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Beethoven</span><span class="dl">"</span></span>)&#x000A;&#x000A;person = <span class="co">Person</span>.new <span class="r">do</span> |p|&#x000A;  p.first_name = <span class="s"><span class="dl">"</span><span class="k">Ludwig</span><span class="dl">"</span></span>&#x000A;  p.last_name = <span class="s"><span class="dl">"</span><span class="k">Beethoven</span><span class="dl">"</span></span>&#x000A;<span class="r">end</span></code></pre>&#x000A;</div>&#x000A;<div class="title">Controlling Access to Fields</div>&#x000A;<div class="text">&#x000A;  <p>&#x000A;    You can protect attributes from mass assignment by using <tt>attr_protected</tt>, or&#x000A;    provide the inverse functionality with <tt>attr_accessible</tt>. This is for&#x000A;    cases where sensitive fields cannot be accidentally set through a form&#x000A;    submission or similar.&#x000A;  </p>&#x000A;  <p>&#x000A;    When using <tt>attr_protected</tt> all other fields will be able to be set&#x000A;    via mass assignment.&#x000A;  </p>&#x000A;  <pre><code class="language-ruby"><span class="r">class</span> <span class="cl">Person</span>&#x000A;  include <span class="co">Mongoid</span>::<span class="co">Document</span>&#x000A;  field <span class="sy">:first_name</span>&#x000A;  attr_protected <span class="sy">:_id</span>&#x000A;<span class="r">end</span></code></pre>&#x000A;  <p>&#x000A;    When using <tt>attr_accessible</tt> all other fields will not be able to be set&#x000A;    via mass assignment.&#x000A;  </p>&#x000A;  <pre><code class="language-ruby"><span class="r">class</span> <span class="cl">Person</span>&#x000A;  include <span class="co">Mongoid</span>::<span class="co">Document</span>&#x000A;  field <span class="sy">:first_name</span>&#x000A;  field <span class="sy">:last_name</span>&#x000A;  attr_accessible <span class="sy">:first_name</span>, <span class="sy">:last_name</span>&#x000A;<span class="r">end</span></code></pre>&#x000A;</div>&#x000A;<div class="title">Dynamic Attributes</div>&#x000A;<div class="text">&#x000A;  <p>&#x000A;    By default Mongoid supports dynamic attributes - that is it will allow&#x000A;    attributes to get set and persisted on the document even if a field&#x000A;    was not defined for them. There is a slight 'gotcha' however when&#x000A;    dealing with dynamic attributes in that Mongoid is not completely&#x000A;    lenient about the use of <tt>method_missing</tt> and breaking the public&#x000A;    interface of the Document class.&#x000A;  </p>&#x000A;  <p>&#x000A;    When dealing with dynamic attributes the following rules apply:&#x000A;  </p>&#x000A;  <ul>&#x000A;<li>&#x000A;      If the attribute exists in the document, Mongoid will provide you&#x000A;      with your standard getter and setter methods. For example, consider&#x000A;      a person who has an attribute of "gender" set on the document:&#x000A;      <pre><code class="language-ruby">person[<span class="sy">:gender</span>] = <span class="s"><span class="dl">"</span><span class="k">Male</span><span class="dl">"</span></span>&#x000A;person.gender <span class="c"># =&gt; returns "Male"</span>&#x000A;person.gender = <span class="s"><span class="dl">"</span><span class="k">Female</span><span class="dl">"</span></span> <span class="c">#=&gt; will set gender to "Female"</span></code></pre>&#x000A;    </li>&#x000A;    <li>&#x000A;      If the attribute does not already exist on the document, Mongoid&#x000A;      will not provide you with the getters and setters and will&#x000A;      enforce normal <tt>method_missing</tt> behavior. In this case you&#x000A;      must use the other provided accessor methods: ( <tt>[]</tt> and&#x000A;      <tt>[]=</tt> ) or ( <tt>read_attribute</tt> and&#x000A;      <tt>write_attribute</tt> ):&#x000A;      <pre><code class="language-ruby">person[<span class="sy">:gender</span>] <span class="c"># =&gt; returns nil</span>&#x000A;person[<span class="sy">:gender</span>] = <span class="s"><span class="dl">"</span><span class="k">Male</span><span class="dl">"</span></span> <span class="c"># =&gt; set gender to "Male"</span>&#x000A;&#x000A;person.read_attribute(<span class="sy">:age</span>) <span class="c"># =&gt; returns nil</span>&#x000A;person.write_attribute(<span class="sy">:age</span>, <span class="i">35</span>) <span class="c"># =&gt; sets age to 35</span></code></pre>&#x000A;    </li>&#x000A;  </ul>&#x000A;</div>&#x000A;<div class="title">Reserved Names</div>&#x000A;<div class="text">&#x000A;  <p>&#x000A;    If you define a field on your document that conflicts with a reserved&#x000A;    method name in Mongoid, the configuration will raise an error. For a list&#x000A;    of these you may look at <tt>Mongoid.destructive_fields</tt>.&#x000A;  </p>&#x000A;</div>&#x000A;&#x000A;
          </div>
        </div>
      </div>
      <div id='rightcolumn'>
        <div class='box' id='search'>
          <div class='roundedbox'>
            <h3>Contents</h3>
          </div>
        </div>
        <ul class='outline'>
          <li><a href="/docs/installation/">Installation</a></li>
          <li><span class="active" title="You're here.">Documents</span></li>
          <li><a href="/docs/associations/">Associations</a></li>
          <li><a href="/docs/persistence/">Persistence</a></li>
          <li><a href="/docs/querying/">Querying</a></li>
          <li><a href="/docs/callbacks/">Callbacks</a></li>
          <li><a href="/docs/validation/">Validation</a></li>
          <li><a href="/docs/inheritance/">Inheritance</a></li>
          <li><a href="/docs/indexing/">Indexing</a></li>
          <li><a href="/docs/extras/">Extras</a></li>
          <li><a href="/docs/rake/">Rake Tasks</a></li>
          <li><a href="/docs/integration/">Integration</a></li>
          <li><a href="/docs/extensions/">Extensions</a></li>
          <li><a href="/docs/upgrading/">Upgrading</a></li>
        </ul>
      </div>
      <div id='footer'>
        <p>
          Mongoid is maintained by <a href="http://twitter.com/modetojoy">Durran Jordan</a>, Site by <a href="http://twitter.com/railsjedi">@railsjedi</a> and <a href="http://twitter.com/fredrikhenne">@fredrikhenne</a>. Mongoid is free software under the MIT license.
        </p>
      </div>
    </div>
    <div id='ribbon'>
      <p>
        <a href='http://github.com/mongoid/mongoid-site' rel='me' title='Fork me on GitHub!'>Fork me on GitHub!</a>
      </p>
    </div>
  </body>
</html>
