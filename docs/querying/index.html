<!DOCTYPE html>
<html lang='en-US' xml:lang='en-US' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <title>Mongoid Documentation: Querying</title>
    <link href='/stylesheets/docs.css' media='all' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <div id='docs'>
      <div id='page_menu'>
        <ul>
          <li class=''>
            <a href='/'>Home</a>
          </li>
          <li class='current_page_item'>
            <a href='/docs/installation/'>Documentation</a>
          </li>
          <li class=''>
            <a href='/links/'>Links</a>
          </li>
          <li class=''>
            <a href='/about/'>About</a>
          </li>
        </ul>
      </div>
      <div id='header'>
        <a href='/'>
          <h1 class='logo' title='[mon-goyd]'>MONGOID</h1>
        </a>
        <a class='docs_header' href='../installation/'>Documentation</a>
      </div>
      <div class='main'>
        <div class='border'>
          <div class='content_body colorize'>
            <h2>Querying</h2>
            <div class="text">&#x000A;  Mongoid supports querying the database for documents usings 2 styles. The first is an&#x000A;  ActiveRecord-like finder/dynamic finder syntax, and the second and preferred method is through Mongoid's&#x000A;  <tt>Criteria</tt> API.&#x000A;  <br><br>&#x000A;</div>&#x000A;<div class="title">Finders</div>&#x000A;<div class="text">&#x000A;  Finders are class methods on a document that take a hash of conditions or a string to find&#x000A;  an object in the database. They are <tt>Document.all</tt>, <tt>Document.count</tt>,&#x000A;  <tt>Document.find</tt>, <tt>Document.first</tt>, <tt>Document.last</tt>, and <tt>Document.paginate</tt>.&#x000A;  In addition to those a finder/creation syntax is also supported where the supplied attributes will&#x000A;  create or instantiate and new document if the attributes don't provide a match.&#x000A;  <br><br>&#x000A;  Finding all documents given some conditions:&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.all(<span class="sy">:conditions</span> =&gt; { <span class="sy">:first_name</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Syd</span><span class="dl">"</span></span> })&#x000A;<span class="co">Person</span>.find(<span class="sy">:all</span>, <span class="sy">:conditions</span> =&gt; { <span class="sy">:first_name</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Syd</span><span class="dl">"</span></span> })</code></pre>&#x000A;  <br>&#x000A;  Find the first document given some conditions:&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.first(<span class="sy">:conditions</span> =&gt; { <span class="sy">:first_name</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Syd</span><span class="dl">"</span></span> })&#x000A;<span class="co">Person</span>.find(<span class="sy">:first</span>, <span class="sy">:conditions</span> =&gt; { <span class="sy">:first_name</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Syd</span><span class="dl">"</span></span> })</code></pre>&#x000A;  <br>&#x000A;  Find the last document given some conditions. If no sorting parameter is provided then the id&#x000A;  field will be used to reverse the sort.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.last(<span class="sy">:conditions</span> =&gt; { <span class="sy">:first_name</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Syd</span><span class="dl">"</span></span> })&#x000A;<span class="co">Person</span>.find(<span class="sy">:last</span>, <span class="sy">:conditions</span> =&gt; { <span class="sy">:first_name</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Syd</span><span class="dl">"</span></span> })</code></pre>&#x000A;  <br>&#x000A;  Find using a dynamic finder - if the object does not exist then create/instantiate it:&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.find_or_create_by(<span class="sy">:first_name</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Syd</span><span class="dl">"</span></span>)&#x000A;<span class="co">Person</span>.find_or_initialize_by(<span class="sy">:first_name</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Syd</span><span class="dl">"</span></span>)</code></pre>&#x000A;</div>&#x000A;<div class="title">Criteria API</div>&#x000A;<div class="text">&#x000A;  The preferred method of querying the database is through the criteria API, which is a DSL&#x000A;  which will make those familiar with SQL very comfortable. <tt>Criteria</tt> queries are lazy loaded&#x000A;  from the database, and can be chained infinitely.&#x000A;  <br><br>&#x000A;  There are several different ways of creating a new criteria:&#x000A;  <pre><code class="language-ruby">all_people = <span class="co">Mongoid</span>::<span class="co">Criteria</span>.new(<span class="co">Person</span>)&#x000A;all_people_again = <span class="co">Person</span>.criteria&#x000A;all_people_names_only = <span class="co">Person</span>.only(<span class="sy">:first_name</span>, <span class="sy">:last_name</span>)&#x000A;people_over_18 = <span class="co">Person</span>.where(<span class="sy">:age</span>.gt =&gt; <span class="i">18</span>)</code></pre>&#x000A;  In the above example the first two will create an empty criteria for the person, where the third will&#x000A;  automatically add a field selection criterion to it and the fourth will create one with a where&#x000A;  selector already added. You may use any entry point method defined in <tt>Mongoid::Finders</tt>, which&#x000A;  are class methods on your document class. These are listed below.&#x000A;</div>&#x000A;<br><div class="title">Criteria Methods</div>&#x000A;<div class="text">&#x000A;  Various types of criteria can be added by chaining - the list of available methods are:&#x000A;  <br><br><tt>Criteria#all_in</tt>: Matches if all values provided match, useful for doing exact matches on arrays.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.all_in(<span class="sy">:aliases</span> =&gt; [ <span class="s"><span class="dl">"</span><span class="k">Jeffrey</span><span class="dl">"</span></span>, <span class="s"><span class="dl">"</span><span class="k">The Dude</span><span class="dl">"</span></span> ])</code></pre>&#x000A;  <br><tt>Criteria#any_in</tt>: Matches documents that have a field matching any value in the array.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.any_in(<span class="sy">:status</span> =&gt; [<span class="s"><span class="dl">"</span><span class="k">Single</span><span class="dl">"</span></span>, <span class="s"><span class="dl">"</span><span class="k">Divorced</span><span class="dl">"</span></span>, <span class="s"><span class="dl">"</span><span class="k">Separated</span><span class="dl">"</span></span>])</code></pre>&#x000A;  <br><tt>Criteria#any_of</tt>: Matches documents that have any of the provided matches.&#x000A;  This is a $or query in MongoDB and can include multiple fields or multiple&#x000A;  conditions for the same field.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.any_of({ <span class="sy">:status</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Single</span><span class="dl">"</span></span> }, { <span class="sy">:preference</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Open</span><span class="dl">"</span></span> })</code></pre>&#x000A;  <br><tt>Criteria#and</tt>: Matches documents for each field/value pair. Aliased from where, it's just&#x000A;  nice syntactic sugar.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.and(<span class="sy">:age</span>.gt =&gt; <span class="i">18</span>, <span class="sy">:gender</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Male</span><span class="dl">"</span></span>)</code></pre>&#x000A;  <br><tt>Criteria#count</tt>: This must be chained behind another criterion not to interfere with&#x000A;  the ActiveRecord style count.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.where(<span class="sy">:status</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Married</span><span class="dl">"</span></span>).count</code></pre>&#x000A;  <br><tt>Criteria#excludes</tt>: Matches documents that don't match the key value pairs&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.excludes(<span class="sy">:status</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Married</span><span class="dl">"</span></span>)</code></pre>&#x000A;  <br><tt>Criteria#id</tt>: Matches a document with the supplied id.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.criteria.id(<span class="s"><span class="dl">"</span><span class="k">4b2fe28ee2dc9b5f7b000029</span><span class="dl">"</span></span>)</code></pre>&#x000A;  <br><tt>Criteria#limit</tt>: Limits the results to a certain number.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.limit(<span class="i">20</span>)</code></pre>&#x000A;  <br><tt>Criteria#near</tt>: Do a geospacial query for a point a certain distance away.&#x000A;  <pre><code class="language-ruby"><span class="co">Address</span>.near(<span class="sy">:position</span> =&gt; [ <span class="fl">37.7</span>, <span class="fl">-122.4</span>, <span class="i">10</span> ])</code></pre>&#x000A;  <br><tt>Criteria#not_in</tt>: Matches when document values are not in the list.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.not_in(<span class="sy">:status</span> =&gt; [<span class="s"><span class="dl">"</span><span class="k">Divorced</span><span class="dl">"</span></span>, <span class="s"><span class="dl">"</span><span class="k">Single</span><span class="dl">"</span></span>])</code></pre>&#x000A;  <br><tt>Criteria#only</tt>: Limits the fields returned from the database.&#x000A;  Useful for list optimization.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.only(<span class="sy">:first_name</span>, <span class="sy">:last_name</span>)</code></pre>&#x000A;  <br><tt>Criteria#order_by</tt>: Adds sorting criteria. (Note - always index fields you sort on)&#x000A;  <pre><code class="language-ruby"><span class="c"># chain asc/ascending and desc/descending to the criteria</span>&#x000A;<span class="co">Person</span>.desc(<span class="sy">:last_name</span>).asc(<span class="sy">:first_name</span>)&#x000A;<span class="co">Person</span>.descending(<span class="sy">:last_name</span>).ascending(<span class="sy">:first_name</span>)</code></pre>&#x000A;  <pre><code class="language-ruby"><span class="c"># pass in a list of symbols</span>&#x000A;<span class="co">Person</span>.order_by(<span class="sy">:last_name</span>.desc, <span class="sy">:first_name</span>.asc, <span class="sy">:city</span>.desc)</code></pre>&#x000A;  <pre><code class="language-ruby"><span class="c"># you can alternatively pass in an array of arrays</span>&#x000A;<span class="co">Person</span>.order_by([[<span class="sy">:last_name</span>, <span class="sy">:desc</span>], [<span class="sy">:first_name</span>, <span class="sy">:asc</span>]])</code></pre>&#x000A;  <br><tt>Criteria#skip</tt>: Skips n number of documents, similar to a traditional offset.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.skip(<span class="i">100</span>)</code></pre>&#x000A;  <br><tt>Criteria#where</tt>: Matches documents for each field/value pair.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.where(<span class="sy">:age</span>.gt =&gt; <span class="i">18</span>, <span class="sy">:gender</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Male</span><span class="dl">"</span></span>)</code></pre>&#x000A;  <br>&#x000A;</div>&#x000A;<div class="title">Regular Expressions</div>&#x000A;<div class="text">&#x000A;  You can pass regular expressions for string matching.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.where(<span class="sy">:last_name</span> =&gt; <span class="rx"><span class="dl">/</span><span class="k">^Jord</span><span class="dl">/</span></span>)</code></pre>&#x000A;  <br>&#x000A;</div>&#x000A;<div class="title">Multiple Expressions on the Same Field</div>&#x000A;<div class="text">&#x000A;  Mongoid will combine them into a single expression.&#x000A;  <pre><code class="language-ruby"><span class="c"># Creates a { "age" =&gt; { "$gt" =&gt; 18, "$lt" =&gt; 30 } } selector.</span>&#x000A;<span class="co">Person</span>.where(<span class="sy">:age</span>.gt =&gt; <span class="i">18</span>, <span class="sy">:age</span>.lt =&gt; <span class="i">30</span>)</code></pre>&#x000A;  <br>&#x000A;</div>&#x000A;<div class="title">Putting It All Together</div>&#x000A;<div class="text">&#x000A;  Return only the first and last names for a person with a post code of 94133:&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.only(<span class="sy">:first_name</span>, <span class="sy">:last_name</span>).where(<span class="s"><span class="dl">"</span><span class="k">address.post_code</span><span class="dl">"</span></span> =&gt; <span class="s"><span class="dl">"</span><span class="k">94133</span><span class="dl">"</span></span>)</code></pre>&#x000A;  <br>&#x000A;  Return only the first names for people whos last names are "Vicious" and have a US phone number.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.only(<span class="sy">:first_name</span>).where(<span class="s"><span class="dl">"</span><span class="k">phones.country_code</span><span class="dl">"</span></span> =&gt; <span class="i">1</span>).in(<span class="sy">:last_name</span> =&gt; [<span class="s"><span class="dl">"</span><span class="k">Vicious</span><span class="dl">"</span></span>])</code></pre>&#x000A;  <br>&#x000A;  Return all fields for people with last names of "Zorg" and middle initals of "J"&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.where(<span class="sy">:last_name</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Zorg</span><span class="dl">"</span></span>).and(<span class="sy">:middle_initial</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">J</span><span class="dl">"</span></span>)</code></pre>&#x000A;  <br>&#x000A;  Criteria where clause examples using MongoDB expressions:&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.where(<span class="sy">:title</span>.all =&gt; [<span class="s"><span class="dl">"</span><span class="k">Sir</span><span class="dl">"</span></span>])&#x000A;<span class="co">Person</span>.where(<span class="sy">:age</span>.exists =&gt; <span class="pc">true</span>)&#x000A;<span class="co">Person</span>.where(<span class="sy">:age</span>.gt =&gt; <span class="i">18</span>)&#x000A;<span class="co">Person</span>.where(<span class="sy">:age</span>.gte =&gt; <span class="i">18</span>)&#x000A;<span class="co">Person</span>.where(<span class="sy">:title</span>.in =&gt; [<span class="s"><span class="dl">"</span><span class="k">Sir</span><span class="dl">"</span></span>, <span class="s"><span class="dl">"</span><span class="k">Madam</span><span class="dl">"</span></span>])&#x000A;<span class="co">Person</span>.where(<span class="sy">:age</span>.lt =&gt; <span class="i">55</span>)&#x000A;<span class="co">Person</span>.where(<span class="sy">:age</span>.lte =&gt; <span class="i">55</span>)&#x000A;<span class="co">Person</span>.where(<span class="sy">:title</span>.ne =&gt; <span class="s"><span class="dl">"</span><span class="k">Mr</span><span class="dl">"</span></span>)&#x000A;<span class="co">Person</span>.where(<span class="sy">:title</span>.nin =&gt; [<span class="s"><span class="dl">"</span><span class="k">Esquire</span><span class="dl">"</span></span>])&#x000A;<span class="co">Person</span>.where(<span class="sy">:aliases</span>.size =&gt; <span class="i">2</span>)&#x000A;<span class="co">Person</span>.where(<span class="sy">:location</span>.near =&gt; [ <span class="fl">22.5</span>, <span class="fl">-21.33</span> ])&#x000A;<span class="co">Person</span>.where(<span class="sy">:location</span>.within =&gt; { <span class="s"><span class="dl">"</span><span class="k">$center</span><span class="dl">"</span></span> =&gt; [ [ <span class="i">50</span>, <span class="i">-40</span> ], <span class="i">1</span> ] })</code></pre>&#x000A;  <br>&#x000A;</div>&#x000A;<div class="title">Chaining Criteria</div>&#x000A;<div class="text">&#x000A;  Criteria can be chained using class methods on a document, similar to DataMapper. The following&#x000A;  example will return results for men over age 60:&#x000A;  <br><br><tt>person.rb</tt>:&#x000A;  <pre><code class="language-ruby"><span class="r">class</span> <span class="cl">Person</span>&#x000A;  include <span class="co">Mongoid</span>::<span class="co">Document</span>&#x000A;&#x000A;  field <span class="sy">:gender</span>&#x000A;  field <span class="sy">:age</span>&#x000A;&#x000A;  <span class="r">class</span> &lt;&lt; <span class="cl">self</span>&#x000A;    <span class="r">def</span> <span class="fu">men</span>&#x000A;      criteria.where(<span class="sy">:gender</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Male</span><span class="dl">"</span></span>)&#x000A;    <span class="r">end</span>&#x000A;    <span class="r">def</span> <span class="fu">old</span>&#x000A;      criteria.where(<span class="sy">:age</span> =&gt; { <span class="s"><span class="dl">"</span><span class="k">$gt</span><span class="dl">"</span></span> =&gt; <span class="i">60</span> })&#x000A;    <span class="r">end</span>&#x000A;  <span class="r">end</span>&#x000A;<span class="r">end</span>&#x000A;&#x000A;<span class="co">Person</span>.old.men <span class="c"># Returns a new criteria of the 2 merged.</span></code></pre>&#x000A;</div>&#x000A;<br><div class="title">Arithmetic, Grouping and Aggregation</div>&#x000A;<div class="text">&#x000A;  Mongoid currently supports some basic arithmetic operations, grouping, and aggregation out of the box.&#x000A;  <br><br>&#x000A;  Find the max value or min value in the database for a single field, returns a float:&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.max(<span class="sy">:age</span>)&#x000A;<span class="co">Person</span>.min(<span class="sy">:age</span>)</code></pre>&#x000A;  <br>&#x000A;  Find the sum of a field across all documents, returns a float:&#x000A;  <pre><code class="language-ruby"><span class="co">Invoice</span>.sum(<span class="sy">:total</span>)</code></pre>&#x000A;  <br>&#x000A;  Get aggregate counts for supplied fields on all documents, this returns an array of hashes with key&#x000A;  being the field value, and value being the count:&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.only(<span class="sy">:first_name</span>).where(<span class="sy">:age</span>.gt =&gt; <span class="i">18</span>).aggregate</code></pre>&#x000A;  <br>&#x000A;  Get groups of documents for supplied fields, this returns an array of hashes with key being the field value,&#x000A;  and value being an array of documents. The entire result set must fit in memory.&#x000A;  <pre><code class="language-ruby"><span class="co">Person</span>.only(<span class="sy">:first_name</span>).where(<span class="sy">:age</span>.gt =&gt; <span class="i">18</span>).group</code></pre>&#x000A;  <br>&#x000A;</div>&#x000A;<div class="title">Scopes</div>&#x000A;<div class="text">&#x000A;  Mongoid supports scopes very similar to ActiveRecord 3.0 scopes. A `scope` can provide a hash,&#x000A;  a proc with a hash, a criteria, or a proc with a criteria. You may also provide an additional&#x000A;  block to a scope if you want extensions added to it. Scopes can exist on root document classes&#x000A;  or embedded has many association classes.&#x000A;  Scopes on association classes cannot be called directly off the class, they must be called on the&#x000A;  association itself on the parent class instance. These scopes also do not require the association to have&#x000A;  been persisted. An Example is at the bottom.&#x000A;  <br><br>&#x000A;  Named scopes can be chained together, or can be chained with any class method that returns&#x000A;  a criteria. The following example describes all cases:&#x000A;  <br><pre><code class="language-ruby"><span class="r">class</span> <span class="cl">Player</span>&#x000A;  include <span class="co">Mongoid</span>::<span class="co">Document</span>&#x000A;  field <span class="sy">:active</span>, <span class="sy">:type</span> =&gt; <span class="co">Boolean</span>&#x000A;  field <span class="sy">:frags</span>, <span class="sy">:type</span> =&gt; <span class="co">Integer</span>&#x000A;  field <span class="sy">:deaths</span>, <span class="sy">:type</span> =&gt; <span class="co">Integer</span>&#x000A;  field <span class="sy">:status</span>&#x000A;&#x000A;  embeds_many <span class="sy">:games</span>&#x000A;&#x000A;  scope <span class="sy">:active</span>, where(<span class="sy">:active</span> =&gt; <span class="pc">true</span>) <span class="r">do</span>&#x000A;    <span class="r">def</span> <span class="fu">count</span>&#x000A;      size&#x000A;    <span class="r">end</span>&#x000A;  <span class="r">end</span>&#x000A;  scope <span class="sy">:inactive</span>, <span class="sy">:where</span> =&gt; { <span class="sy">:active</span> =&gt; <span class="pc">false</span> }&#x000A;  scope <span class="sy">:frags_over</span>, lambda { |count| { <span class="sy">:where</span> =&gt; { <span class="sy">:frags</span>.gt =&gt; count } } }&#x000A;  scope <span class="sy">:deaths_under</span>, lambda { |count| where(<span class="sy">:deaths</span>.lt =&gt; count) }&#x000A;&#x000A;  <span class="r">class</span> &lt;&lt; <span class="cl">self</span>&#x000A;    <span class="r">def</span> <span class="fu">alive</span>&#x000A;      where(<span class="sy">:status</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Alive</span><span class="dl">"</span></span>)&#x000A;    <span class="r">end</span>&#x000A;  <span class="r">end</span>&#x000A;<span class="r">end</span>&#x000A;&#x000A;<span class="r">class</span> <span class="cl">Game</span>&#x000A;  include <span class="co">Mongoid</span>::<span class="co">Document</span>&#x000A;  field <span class="sy">:saved</span>, <span class="sy">:type</span> =&gt; <span class="co">Boolean</span>, <span class="sy">:default</span> =&gt; <span class="pc">false</span>&#x000A;  field <span class="sy">:level</span>, <span class="sy">:type</span> =&gt; <span class="co">Integer</span>, <span class="sy">:default</span> =&gt; <span class="i">1</span>&#x000A;  field <span class="sy">:studio</span>&#x000A;  embedded_in <span class="sy">:player</span>, <span class="sy">:inverse_of</span> =&gt; <span class="sy">:games</span>&#x000A;&#x000A;  scope <span class="sy">:saved</span>, where(<span class="sy">:saved</span> =&gt; <span class="pc">true</span>)&#x000A;&#x000A;  <span class="r">class</span> &lt;&lt; <span class="cl">self</span>&#x000A;    <span class="r">def</span> <span class="fu">blizzard</span>&#x000A;      where(<span class="sy">:studio</span> =&gt; <span class="s"><span class="dl">"</span><span class="k">Blizzard</span><span class="dl">"</span></span>)&#x000A;    <span class="r">end</span>&#x000A;  <span class="r">end</span>&#x000A;<span class="r">end</span>&#x000A;&#x000A;<span class="co">Player</span>.active <span class="c"># Returns active players.</span>&#x000A;<span class="co">Player</span>.active.count <span class="c"># Returns the count of active players.</span>&#x000A;<span class="co">Player</span>.active.alive <span class="c"># Returns active players that are alive.</span>&#x000A;<span class="co">Player</span>.inactive.frags_over(<span class="i">10</span>) <span class="c"># Returns inactive players with over 10 frags.</span>&#x000A;<span class="co">Player</span>.deaths_under(<span class="i">30</span>) <span class="c"># Returns players with under 30 deaths.</span>&#x000A;&#x000A;player = <span class="co">Player</span>.find(id)&#x000A;player.games.saved <span class="c"># Returns the players saved games</span>&#x000A;player.games.saved.blizzard <span class="c"># Returns the players saved Blizzard games</span></code></pre>&#x000A;</div>&#x000A;&#x000A;
          </div>
        </div>
      </div>
      <div id='rightcolumn'>
        <div class='box' id='search'>
          <div class='roundedbox'>
            <h3>Contents</h3>
          </div>
        </div>
        <ul class='outline'>
          <li><a href="/docs/installation/">Installation</a></li>
          <li><a href="/docs/documents/">Documents</a></li>
          <li><a href="/docs/associations/">Associations</a></li>
          <li><a href="/docs/persistence/">Persistence</a></li>
          <li><span class="active" title="You're here.">Querying</span></li>
          <li><a href="/docs/callbacks/">Callbacks</a></li>
          <li><a href="/docs/validation/">Validation</a></li>
          <li><a href="/docs/inheritance/">Inheritance</a></li>
          <li><a href="/docs/indexing/">Indexing</a></li>
          <li><a href="/docs/extras/">Extras</a></li>
          <li><a href="/docs/rake/">Rake Tasks</a></li>
          <li><a href="/docs/integration/">Integration</a></li>
          <li><a href="/docs/extensions/">Extensions</a></li>
          <li><a href="/docs/upgrading/">Upgrading</a></li>
        </ul>
      </div>
      <div id='footer'>
        <p>
          Mongoid is maintained by <a href="http://twitter.com/modetojoy">Durran Jordan</a>, Site by <a href="http://twitter.com/railsjedi">@railsjedi</a> and <a href="http://twitter.com/fredrikhenne">@fredrikhenne</a>. Mongoid is free software under the MIT license.
        </p>
      </div>
    </div>
    <div id='ribbon'>
      <p>
        <a href='http://github.com/mongoid/mongoid-site' rel='me' title='Fork me on GitHub!'>Fork me on GitHub!</a>
      </p>
    </div>
  </body>
</html>
